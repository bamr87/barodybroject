name: Infrastructure Testing

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  schedule:
    # Run infrastructure tests daily at 2 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch:
    inputs:
      verbose:
        description: 'Enable verbose output'
        required: false
        default: false
        type: boolean
      skip_cleanup:
        description: 'Skip cleanup after tests'
        required: false
        default: false
        type: boolean

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  PYTHON_VERSION: "3.11"
  DJANGO_SETTINGS_MODULE: "barodybroject.test_settings"

jobs:
  infrastructure-test:
    name: Comprehensive Infrastructure Testing
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Create environment configuration
        run: |
          cat > .env << EOL
          POSTGRES_USER=test_user
          POSTGRES_DB=test_db
          POSTGRES_PASSWORD=test_password
          DB_HOST=barodydb
          DB_USERNAME=test_user
          DB_NAME=test_db
          DB_PASSWORD=test_password
          DJANGO_SETTINGS_MODULE=barodybroject.test_settings
          DEBUG=True
          RUNNING_IN_PRODUCTION=False
          PYTHONPATH=/workspace/src:/workspace
          PYTHONUNBUFFERED=1
          SECRET_KEY=ci-test-key-not-for-production-infrastructure-testing
          EOL

      - name: Create test settings file
        run: |
          mkdir -p src/barodybroject
          cat > src/barodybroject/test_settings.py << 'EOL'
          """
          Django settings for infrastructure testing
          """
          import os
          from pathlib import Path

          # Build paths inside the project like this: BASE_DIR / 'subdir'.
          BASE_DIR = Path(__file__).resolve().parent.parent

          # SECURITY WARNING: keep the secret key used in production secret!
          SECRET_KEY = os.environ.get('SECRET_KEY', 'ci-test-key-not-for-production')

          # SECURITY WARNING: don't run with debug turned on in production!
          DEBUG = True

          ALLOWED_HOSTS = ['*']

          # Application definition
          INSTALLED_APPS = [
              'django.contrib.admin',
              'django.contrib.auth',
              'django.contrib.contenttypes',
              'django.contrib.sessions',
              'django.contrib.messages',
              'django.contrib.staticfiles',
              'setup',  # Installation wizard app
          ]

          MIDDLEWARE = [
              'django.middleware.security.SecurityMiddleware',
              'django.contrib.sessions.middleware.SessionMiddleware',
              'django.middleware.common.CommonMiddleware',
              'django.middleware.csrf.CsrfViewMiddleware',
              'django.contrib.auth.middleware.AuthenticationMiddleware',
              'django.contrib.messages.middleware.MessageMiddleware',
              'django.middleware.clickjacking.XFrameOptionsMiddleware',
              'setup.middleware.InstallationMiddleware',
          ]

          ROOT_URLCONF = 'barodybroject.urls'

          TEMPLATES = [
              {
                  'BACKEND': 'django.template.backends.django.DjangoTemplates',
                  'DIRS': [BASE_DIR / 'templates'],
                  'APP_DIRS': True,
                  'OPTIONS': {
                      'context_processors': [
                          'django.template.context_processors.debug',
                          'django.template.context_processors.request',
                          'django.contrib.auth.context_processors.auth',
                          'django.contrib.messages.context_processors.messages',
                      ],
                  },
              },
          ]

          # Database for testing (SQLite for CI simplicity)
          DATABASES = {
              'default': {
                  'ENGINE': 'django.db.backends.sqlite3',
                  'NAME': BASE_DIR / 'test_db.sqlite3',
              }
          }

          # Internationalization
          LANGUAGE_CODE = 'en-us'
          TIME_ZONE = 'UTC'
          USE_I18N = True
          USE_TZ = True

          # Static files (CSS, JavaScript, Images)
          STATIC_URL = '/static/'
          STATIC_ROOT = BASE_DIR / 'staticfiles'

          # Default primary key field type
          DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

          # Logging
          LOGGING = {
              'version': 1,
              'disable_existing_loggers': False,
              'handlers': {
                  'console': {
                      'class': 'logging.StreamHandler',
                  },
              },
              'root': {
                  'handlers': ['console'],
                  'level': 'INFO',
              },
          }

          # Setup wizard configuration
          SETUP_WIZARD_CONFIG_DIR = BASE_DIR / 'config'
          EOL

      - name: Create logs directory
        run: mkdir -p logs

      - name: Build and start Docker services
        run: |
          echo "ðŸ³ Building and starting Docker services..."
          docker-compose -f .devcontainer/docker-compose_dev.yml build --parallel
          docker-compose -f .devcontainer/docker-compose_dev.yml up -d

      - name: Wait for services to be ready
        run: |
          echo "â³ Waiting for services to initialize..."
          
          # Wait for PostgreSQL
          timeout 60 bash -c 'until docker-compose -f .devcontainer/docker-compose_dev.yml exec -T barodydb pg_isready -U test_user -d test_db; do sleep 2; done'
          
          # Wait for Python container
          timeout 60 bash -c 'until docker-compose -f .devcontainer/docker-compose_dev.yml exec -T python echo "Ready"; do sleep 2; done'
          
          echo "âœ… Services are ready"

      - name: Run comprehensive infrastructure tests
        run: |
          echo "ðŸš€ Starting comprehensive infrastructure testing..."
          
          # Set script arguments based on inputs
          SCRIPT_ARGS="--ci-mode"
          if [[ "${{ github.event.inputs.verbose }}" == "true" ]]; then
            SCRIPT_ARGS="$SCRIPT_ARGS --verbose"
          fi
          if [[ "${{ github.event.inputs.skip_cleanup }}" == "true" ]]; then
            SCRIPT_ARGS="$SCRIPT_ARGS --skip-cleanup"
          fi
          
          # Run the infrastructure test script
          ./scripts/test-infrastructure.sh $SCRIPT_ARGS

      - name: Collect test logs
        if: always()
        run: |
          echo "ðŸ“‹ Collecting test logs..."
          
          # Create artifacts directory
          mkdir -p artifacts/logs
          
          # Copy application logs
          if [ -d logs ]; then
            cp -r logs/* artifacts/logs/ || echo "No application logs found"
          fi
          
          # Get Docker logs
          echo "ðŸ³ Collecting Docker container logs..."
          docker-compose -f .devcontainer/docker-compose_dev.yml logs --no-color > artifacts/logs/docker-compose.log 2>&1 || echo "Failed to collect Docker logs"
          
          # Get individual container logs
          docker-compose -f .devcontainer/docker-compose_dev.yml logs --no-color python > artifacts/logs/python-container.log 2>&1 || echo "Failed to collect Python logs"
          docker-compose -f .devcontainer/docker-compose_dev.yml logs --no-color barodydb > artifacts/logs/postgres-container.log 2>&1 || echo "Failed to collect PostgreSQL logs"
          docker-compose -f .devcontainer/docker-compose_dev.yml logs --no-color jekyll > artifacts/logs/jekyll-container.log 2>&1 || echo "Failed to collect Jekyll logs"
          
          # Get system information
          echo "ðŸ” Collecting system information..."
          docker system df > artifacts/logs/docker-system-info.log 2>&1 || echo "Failed to collect Docker system info"
          docker-compose -f .devcontainer/docker-compose_dev.yml ps > artifacts/logs/container-status.log 2>&1 || echo "Failed to collect container status"
          
          echo "ðŸ“ Log collection completed"

      - name: Upload test artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: infrastructure-test-artifacts-${{ github.run_id }}
          path: artifacts/
          retention-days: 7

      - name: Generate test summary
        if: always()
        run: |
          echo "## ðŸ”§ Infrastructure Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ -f logs/infrastructure-test-*.log ]; then
            latest_log=$(ls -t logs/infrastructure-test-*.log | head -1)
            echo "### Test Execution Summary" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            tail -20 "$latest_log" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "### âš ï¸ Test Log Not Found" >> $GITHUB_STEP_SUMMARY
            echo "Could not locate infrastructure test log file." >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“Š Container Status" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          docker-compose -f .devcontainer/docker-compose_dev.yml ps >> $GITHUB_STEP_SUMMARY 2>&1 || echo "Failed to get container status" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ”— Artifacts" >> $GITHUB_STEP_SUMMARY
          echo "- Full test logs and Docker container logs available in artifacts" >> $GITHUB_STEP_SUMMARY
          echo "- Artifact name: \`infrastructure-test-artifacts-${{ github.run_id }}\`" >> $GITHUB_STEP_SUMMARY

      - name: Cleanup Docker environment
        if: always() && github.event.inputs.skip_cleanup != 'true'
        run: |
          echo "ðŸ§¹ Cleaning up Docker environment..."
          docker-compose -f .devcontainer/docker-compose_dev.yml down -v --remove-orphans || echo "Cleanup completed with warnings"
          docker system prune -f || echo "Docker system prune completed"

  # Unit tests validation (separate job for parallel execution)
  unit-tests-validation:
    name: Unit Tests Validation
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          cd src
          python -m pip install --upgrade pip
          pip install pytest pytest-django pytest-cov django

      - name: Create minimal test settings
        run: |
          cat > src/barodybroject/test_minimal.py << 'EOL'
          import os
          from pathlib import Path

          BASE_DIR = Path(__file__).resolve().parent.parent
          SECRET_KEY = 'test-key'
          DEBUG = True
          ALLOWED_HOSTS = ['*']

          INSTALLED_APPS = [
              'django.contrib.auth',
              'django.contrib.contenttypes',
              'setup',
          ]

          DATABASES = {
              'default': {
                  'ENGINE': 'django.db.backends.sqlite3',
                  'NAME': ':memory:',
              }
          }

          USE_TZ = True
          SETUP_WIZARD_CONFIG_DIR = BASE_DIR / 'config'
          EOL

      - name: Run unit tests
        run: |
          cd src
          export DJANGO_SETTINGS_MODULE=barodybroject.test_minimal
          python -m pytest ../test/unit/test_services.py -v --tb=short
        env:
          PYTHONPATH: ${{ github.workspace }}/src

  # Summary job
  infrastructure-test-summary:
    name: Infrastructure Test Summary
    runs-on: ubuntu-latest
    needs: [infrastructure-test, unit-tests-validation]
    if: always()

    steps:
      - name: Check all jobs status
        run: |
          echo "Infrastructure Test: ${{ needs.infrastructure-test.result }}"
          echo "Unit Tests Validation: ${{ needs.unit-tests-validation.result }}"
          
          if [[ "${{ needs.infrastructure-test.result }}" == "failure" || 
                "${{ needs.unit-tests-validation.result }}" == "failure" ]]; then
            echo "âŒ Infrastructure Testing Pipeline Failed"
            echo "::error::One or more infrastructure tests failed. Please review the logs."
            exit 1
          elif [[ "${{ needs.infrastructure-test.result }}" == "success" && 
                  "${{ needs.unit-tests-validation.result }}" == "success" ]]; then
            echo "âœ… Infrastructure Testing Pipeline Passed"
            echo "ðŸŽ‰ All infrastructure components validated successfully!"
          else
            echo "âš ï¸ Infrastructure Testing Pipeline Completed with Warnings"
            echo "Some jobs were skipped or cancelled."
          fi